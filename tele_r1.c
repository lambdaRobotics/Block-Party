#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Motor,  motorA,          combine_r,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          combine_l,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     basket,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     rack_pinion_r, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     rearRight,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     rack_pinion_l, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     rearLeft,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S2_C1_1,    servo_hook,           tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    servo_auto,           tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo_basket,         tServoStandard)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/************************ PROGRAM DESCRIPTION   ****************************/
/* Tele_r1.c: Teleop mode, release 1 (Naming convetion: Tele or Auto; r#: releae number)
/* This program is to allow manual operation or robot in tele-op phase (include end game)
/*
/* Program Operation:
/* step 1: initialize robot servos, placed in desired position.
/*         hook_servo: in closed down position;
/*         auto_servo: in upright position, get out of way of flag motor handel;
/*         basket_servo: in level position, slight away from floor to allow free movement of robot
/*         motor encoders: geneerally in zero positions;
/************************  End of Description   ***************************/

/************************ SYSTEM INCLUDE FILES  ****************************/
/* System include files added here
/***************************************************************************/

// Lotitech joystick file; I copied this into my local direction
//                         your path may be different
#include "JoystickDriver.c"

// Hi-Technic Sensor Multeplexer file
#include "drivers/hitechnic-sensormux.h"

/************************  End of System Include Files   ***************************/

/************************ GLOBAL CONSTANTS & VARIABLES  ****************************/
// global constants
#define powerlevel_fine_movement 30     // motor power used in small movement steps
#define encoder_step_per_inch    147    // encoder step for per inch robot movement straight
#define combine_power            100    // combine NXT motor power level
#define combine_power_half       50     // half of combine power level for toggle control

// global variables
int last_encoder_elevator;              // last motor encoder recording


/************************ END OF GLOBAL CONSTANTS AND VARIABLES  ****************************/



/************************ FUNCTION DECLARATIONS  ****************************/

void initializeRobot();                 // robot initialization task
void joystick_motor_control ();         // joystick control task


/******************************  MAIN TASK      ****************************/

task main()
{

 initializeRobot();                     // initialize robot first; pay attention to servo positions!

 waitForStart();                        // wait for start of tele-op phase by FTC operator!!

 /* program wait before going further unless 'teleop running' is selected */

 servo[servo_auto] = 80;                // place servo_auto in upright, lean slight outside; get out of flag motor's way

 while (true)
  {
   joystick_motor_control();	//joystick control for teleop mode

  }

}

/******************************  END OF MAIN TASK      ***********************/


/******************************  TASK DEFINITIONS     ***********************/


// initialize robot: servo initial positions encoder reading reset, etc
void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

   motor[rack_pinion_l] = 0;
   motor[rack_pinion_r] = 0;
   motor[combine_l] = 0;
   motor[combine_r] = 0;
   motor[basket] = 0;
   motor[flag] = 0;
   motor[rearLeft] = 0;
   motor[rearRight] = 0;
   motor[frontLeft] = 0;
   motor[frontRight] = 0;

   nMotorEncoder[rearLeft] = 0;
   nMotorEncoder[rearRight] = 0;


   servo[servo_basket] = 200;              // basket servo in level, slight away from floor position
   servo[servo_hook] = 60;                 // book servo in closed, down position;
   servo[servo_auto] = 210;                // 10=dump: 100=upright;  210=hold block; 80=upright, lean outside a little

   servoChangeRate[servo_basket] = 5;

   last_encoder_elevator = 0;

  return;
}

// Joystick motor control routine
void joystick_motor_control ()
{
	  getJoystickSettings(joystick);

  // flag motor control, threshold set at +/- 65 to prevent unintended activation
    if (joystick.joy1_x2 > 65 || joystick.joy1_x2 <-65) {
      motor[flag] = joystick.joy1_x2;
    }
    else {
    	motor[flag] = 0;
    }

  // rack dual motor control, threshold set at +/- 65 to prevent unintended activation

    if (joystick.joy1_y2 > 65 || joystick.joy1_y2 <-65) {

      motor[rack_pinion_l] = joystick.joy1_y2;
    	motor[rack_pinion_r] = joystick.joy1_y2;
    }
    else {
    	motor[rack_pinion_l] = 0;
    	motor[rack_pinion_r] = 0;
    }


  // servo basket control: 200 and 100 are limits
  // up
  	if(joy1Btn(6) == 1 ){
  		if(ServoValue[servo_basket] <= 210) {
  			servo[servo_basket] += 4;
  			wait10Msec(1);
  			}
   }
    // down
    if(joy1Btn(5) == 1 ){
    	if(ServoValue[servo_basket] >= 100) {
  			servo[servo_basket] -= 4;
  			wait10Msec(1);
  			}
   }

  // motor basket
  // down
   if(joy1Btn(7) == 1 ){
  	 motor[basket] = -100;
   }

   // up
   else if (joy1Btn(8) == 1) {
     motor[basket] = 100;
   }

   // stop
   else {
     wait10Msec(1);
     motor[basket] = 0;
   }


  // motor combine control: button9,10: toggle motor on/off, in positive and negative directions
  // if motor already running, push button9,10 will stop it; otherwise start in pos. or neg direcion
  // spit out blocks
  // Since these buttons need to work in toggle mode, it's very important to have
  // some de-bouncer control, i.e., make sure the program does not count the button pressed twice
  // when you only intend once.
  // the added delay is a simple way to achieve this, but cause the program a very small delay

   if(joy1Btn(9) == 1 ){
     if (motor[combine_l] < -combine_power_half || motor[combine_l] > combine_power_half) {
       motor[combine_l] = 0;
       motor[combine_r] = 0;
     }
     else {
  	   motor[combine_l] = -combine_power;
  	   motor[combine_r] = -combine_power;
     }
     wait10Msec(50);      // wait 0.2s to prevent count button press twice
  }

  // bring in blocks
   if (joy1Btn(10) == 1) {
     if (motor[combine_l] < -combine_power_half || motor[combine_l] > combine_power_half) {
       motor[combine_l] = 0;
       motor[combine_r] = 0;
     }
     else {
     motor[combine_l] = combine_power;
     motor[combine_r] = combine_power;
     }
     wait10Msec(50);     // wait for 0.2s to prevent count button press twice
   }



  // Moving motors control: Coarse
  // Control works like this: If you push joystick to full throttle position
  // and suddently release the throttle, the motor will coast to a gradual stop; this is
  // to prevent sudden stop of robot from a high speed;
  // on the other hand, if you gradually brings the throttle to a close, the motor will stop
  // immeidately stop, no 'coast down' effect, this is to allow relative precision stop
  // For turning, power level is reduced to allow smooth turn;

   if ((joystick.joy1_y1 < 20 && joystick.joy1_y1 > -20) && joystick.joy1_x1 < 20 && joystick.joy1_x1 > -20) {
     if (motor[frontRight] > 1 || motor[frontRight] < -1)
       motor[frontRight]= motor[frontRight] /4;
     if (motor[rearRight] > 1 || motor[rearRight] < -1)
       motor[rearRight] = motor[rearRight] /4;
     if (motor[frontLeft] > 1 || motor[frontLeft] < -1)
       motor[frontLeft] = motor[frontLeft] /4;
     if (motor[rearLeft] > 1 || motor[rearLeft] < -1)
       motor[rearLeft] = motor[rearLeft] /4;
     //wait1Msec(2);
   }
   else {
    motor[frontRight] = joystick.joy1_y1 - joystick.joy1_x1/2;
  	motor[rearRight]  = joystick.joy1_y1 - joystick.joy1_x1/2;
  	motor[frontLeft]  = joystick.joy1_y1 + joystick.joy1_x1/2;
  	motor[rearLeft]   = joystick.joy1_y1 + joystick.joy1_x1/2;

 }


 // moving motor control: Fine
 // reduced power and clean button control allows small, precise
 // movement of robot for picking and dump blocks etc.
 // in each pass of this joystick_motor_control task, it reads once the
 // joystick.joy1_y1, x1 and then these buttons;
 // if none of these buttons are pressed, the control is solely set by
 // the left joystick;
 // if the joystick is left at zero position, and one of these buttons pressed,
 // the actual value for motor will be set by these buttons, since it overwrite the
 // values set by the joystick left stick

 // forward
  if( joy1Btn(4) == 1) {
  	motor[frontRight] = powerlevel_fine_movement;
  	motor[rearRight]  = powerlevel_fine_movement;
  	motor[frontLeft]  = powerlevel_fine_movement;
  	motor[rearLeft]   = powerlevel_fine_movement;
  }
  // backward
  else if (joy1Btn(2) == 1) {
  	motor[frontRight] = -powerlevel_fine_movement;
  	motor[rearRight]  = -powerlevel_fine_movement;
  	motor[frontLeft]  = -powerlevel_fine_movement;
  	motor[rearLeft]   = -powerlevel_fine_movement;
  }
  //left turn
  else if (joy1Btn(1) == 1){
  	motor[frontLeft]  = -powerlevel_fine_movement;
    motor[rearLeft]   = -powerlevel_fine_movement;
    motor[frontRight] = powerlevel_fine_movement;
    motor[rearRight]  = powerlevel_fine_movement;
  }
  // right turn
  else if (joy1Btn(3) == 1) {
  	motor[frontLeft]  = powerlevel_fine_movement;
    motor[rearLeft]   = powerlevel_fine_movement;
    motor[frontRight] = -powerlevel_fine_movement;
    motor[rearRight]  = -powerlevel_fine_movement;
  }


  // servo hook control
  // up
  if (joystick.joy1_TopHat == 6) {
     servo[servo_hook] =60;
     wait10Msec(1);
          }
  // down
  if (joystick.joy1_TopHat == 2) {
  	servo[servo_hook] = 250;
  	wait10Msec(1);
  }

  /* unused button
  //
  if (joystick.joy1_TopHat == 0) {
  	 if(servo[servo_unused] <=225)
       servo[servo_unused] += 10;
     wait10Msec(1);
          }
  if (joystick.joy1_TopHat == 4) {
  	if(servo[servo_unused] >=0)
  	   servo[servo_unused] -= 10;
  	wait10Msec(1);
  }
  */

}
